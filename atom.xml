<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[code spelunking]]></title>
  <link href="http://timothysc.github.io/timothysc.guthub.io/atom.xml" rel="self"/>
  <link href="http://timothysc.github.io/timothysc.guthub.io/"/>
  <updated>2017-03-04T15:12:21-06:00</updated>
  <id>http://timothysc.github.io/timothysc.guthub.io/</id>
  <author>
    <name><![CDATA[Timothy St. Clair]]></name>
    <email><![CDATA[timothysc@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Moved to Medium]]></title>
    <link href="http://timothysc.github.io/timothysc.guthub.io/blog/2017/03/04/moved-to-medium/"/>
    <updated>2017-03-04T14:37:55-06:00</updated>
    <id>http://timothysc.github.io/timothysc.guthub.io/blog/2017/03/04/moved-to-medium</id>
    <content type="html"><![CDATA[<p><a href="http://medium.com/@timothysc">&ldquo;Link to new location&rdquo;</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started With Mesos on Fedora 21 and CentOS 7]]></title>
    <link href="http://timothysc.github.io/timothysc.guthub.io/blog/2014/09/08/mesos-breeze/"/>
    <updated>2014-09-08T10:00:00-05:00</updated>
    <id>http://timothysc.github.io/timothysc.guthub.io/blog/2014/09/08/mesos-breeze</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://timothysc.github.io/timothysc.guthub.io/images/mesos_logo.png"></p>

<h2>Background</h2>

<p>For decades now, computer scientists have debated on how
to coordinate groups of heterogeneous compute resources to solve a set of domain
specific problems.  &ldquo;Scheduling&rdquo; was the catch all moniker that was used to
describe this space.  This category of problems is <em>old</em>, therefore the
scheduling universe is vast, and expansive.</p>

<p>The most recent generation of schedulers that have emerged, strive to address the
problem of coordinating several distributed applications across a data-center.
The reason why I find this interesting, is that many distributed applications
reinvent aspects of a &ldquo;scheduler&rdquo;, often without realizing the depth and breadth
of the domain they just stepped into.  There is a great ACM article that highlights
this point <a href="http://queue.acm.org/detail.cfm?id=2482856">&ldquo;There&rsquo;s Just No Getting around It: You&rsquo;re Building a Distributed System&rdquo;.</a></p>

<p>Now-a-days, we&rsquo;re seeing a Cambrian explosion of software stacks, each
reinventing pieces of the scheduling wheel.  That&rsquo;s all well and good, but
there is a much easier way.  Enter Apache Mesos, a cluster manager
that provides efficient resource isolation and sharing across distributed
applications.</p>

<p>At its core, Mesos is a <strong>focused</strong> meta-scheduler that provides <strong>primitives</strong> to express a wide
variety of scheduling patterns and use cases. Solutions are <strong>written atop</strong> of Mesos, and are
targeted for a particular use case.  By remaining focused at its core, Mesos
is not architecturally encumbered by domain specific problems that often exist
within other monolithic schedulers.</p>

<hr />

<h2>References</h2>

<ul>
<li><a href="http://youtu.be/YB1VW0LKzJ4">Introduction to Mesos</a></li>
<li><a href="http://youtu.be/VQAAkO5B5Hg?list=UUeDh9omC_xMKrar2srQZiLg">John Wilkes #MesosCon Keynote</a></li>
<li><a href="http://mesos.apache.org/documentation/latest/mesos-architecture/">Mesos Architecture</a></li>
<li><a href="http://youtu.be/hTcZGODnyf0">Building and Running Distributed Systems using Apache Mesos</a></li>
<li><a href="http://mesos.apache.org/documentation/latest/app-framework-development-guide/">Framework Development Guide</a></li>
<li><a href="https://www.youtube.com/user/TwitterUniversity">Twitter University</a></li>
</ul>


<hr />

<h2>Overview</h2>

<p>I often find software first impressions are usually pretty important,
and if I have to spend hours setting up an application, then that usually colors
my perspective about the technology.</p>

<p>Therefore, in this post I will run through how simple it is for you to get started with
Mesos on Fedora 21 and CentOS 7.  <strong>I&rsquo;ll leave HA deployments for another post, because I want
to outline just how simple it is to setup for &ldquo;trying it out&rdquo;.</strong></p>

<hr />

<h2>Prerequisites</h2>

<ul>
<li><a href="http://fedoraproject.org/en/get-fedora">Latest Fedora Machine</a> (OR) <a href="http://www.centos.org/download/">CentOS 7 box </a>with<a href="https://fedoraproject.org/wiki/EPEL"> epel installed</a></li>
</ul>


<h3>CentOS 7</h3>

<p>Currently dependent packages have not been fully pulled into CentOS 7, or epel
channels, but I&rsquo;ve enabled the <a href="http://pkgs.fedoraproject.org/cgit/mesos.git/tree/mesos.spec">mesos.spec</a>
to build a bundled distribution for those who want to run on CentOS 7.  For
convenience, rpms can be found <a href="https://tstclair.fedorapeople.org/mesos/centos7/">here</a></p>

<p>But for those who want to rebuild it for themselves, you can download the <a href="http://koji.fedoraproject.org/koji/packageinfo?packageID=17691">srpm</a> and run:
    $ mock &ndash;clean &ndash;init -r epel-7-x86_64 &ndash;rebuild mesos-0.20.0-2.f421ffd.fc21.src.rpm</p>

<p>You will also need to update your docker installation to 1.X.</p>

<h3>Multi-Node Cluster</h3>

<ul>
<li>If you setting up a multi-node cluster, it is recommended that you have DNS setup.</li>
<li>You may also want to alter your firewall settings.</li>
</ul>


<hr />

<h2>Installation</h2>

<pre><code>$ sudo yum install mesos python-mesos mesos-devel mesos-java
</code></pre>

<hr />

<h2>Setup</h2>

<p>Make sure docker is running:
    $ systemctl start docker</p>

<h3>Single Node</h3>

<p>Out of the box, the package is configured to run mesos on a single host machine.  Which is convenient for
developers who just want to install and test their applications locally before submitting to their cluster.</p>

<h3>Multi-Node</h3>

<p>If you want to setup a multi-node cluster there is simply one parameter you need to set on your worker nodes <em>/etc/mesos/mesos-slave-env.sh</em> file:
    export MESOS_master=yourmaster.yourdomain.com:5050</p>

<hr />

<h2>Running</h2>

<h3>Master Node</h3>

<pre><code>$ systemctl start mesos-master
</code></pre>

<p>and open a browser to <a href="http://localhost:5050">localhost:5050</a></p>

<h3>Worker Node</h3>

<pre><code>$ systemctl start mesos-slave
</code></pre>

<p>Now check the &ldquo;Slaves&rdquo; tab on the browser window to verify.</p>

<h3>Smoke Test</h3>

<pre><code>$ mesos execute --command="/bin/sleep 10" --master="yourmaster.yourdomain.com:5050" --name="whizbang"
</code></pre>

<p>Verify that it ran under the &ldquo;Frameworks&rdquo; tab.</p>

<hr />

<h3>Summary</h3>

<p>Distributed systems can be a complicated and thorny road, but setting up and
deploying them doesn&rsquo;t have to be, and <strong>it&rsquo;s a breeze with Mesos</strong>.</p>

<p><strong>HaPpY HaCkInG!</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hot Rod Hadoop With Tachyon on Fedora 21 (Rawhide)]]></title>
    <link href="http://timothysc.github.io/timothysc.guthub.io/blog/2014/02/17/bdas-tachyon/"/>
    <updated>2014-02-17T10:00:00-06:00</updated>
    <id>http://timothysc.github.io/timothysc.guthub.io/blog/2014/02/17/bdas-tachyon</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://timothysc.github.io/timothysc.guthub.io/images/Tachyon.jpg" title="" ></p>

<h2>Background</h2>

<p>Within the last couple of years we&rsquo;ve witnessed a natural evolution in
the &ldquo;Big Data&rdquo; ecosystem.  Where the common theme that you&rsquo;ve probably heard in the
community that, &ldquo;Memory is King&rdquo;, and it is.  Therefore, if you are looking for performance
optimization in your stack, an &ldquo;in memory&rdquo; layer should be part of
the equation.  Enter <em>Tachyon</em>, which provides reliable file sharing across cluster
frameworks.</p>

<p>Tachyon can be used to support different framworks, as well as different filesystems.
So to bound the scope of this post, we will outline how to setup Tachyon on a local installation
to boost performance of map-reduce application whose data is stored in HDFS on Fedora 21.</p>

<hr />

<h2>Special Thanks</h2>

<p>Tachyon is a recent addition to the Fedora channels, and it would not have been possible
without the efforts of <a href="https://github.com/haoyuan">Haoyuan Li</a>, Gil Cattaneo,
and <a href="http://chapeau.freevariable.com/">William Benton</a></p>

<hr />

<h2>References</h2>

<ul>
<li><a href="https://amplab.cs.berkeley.edu/software/">BDAS Stack</a></li>
<li><a href="http://youtu.be/4lMAsd2LNEE">YouTube - Introduction to Tachyon</a></li>
<li><a href="http://tachyon-project.org/">Tachyon project</a></li>
<li><a href="https://fedoraproject.org/wiki/SIGs/bigdata">Fedora BIG Data SIG</a></li>
<li><a href="http://labs.ericsson.com/blog/going-beyond-hadoop-some-insights-for-big-data-platforms">Going beyond Hadoop</a></li>
</ul>


<hr />

<h2>Prerequisites</h2>

<ul>
<li><a href="http://fedoraproject.org/en/get-fedora">Latest Fedora Machine</a></li>
<li><a href="http://timothysc.github.io/blog/2013/09/14/hadoop-mapreduce/">Bootstrapping Your MapReduce 2.X Programming on Fedora 20</a></li>
</ul>


<hr />

<h2>Installation and Setup</h2>

<p>Prior to installing Tachyon please ensure that you have setup your hadoop installation
as outlined in the pre-reqs.</p>

<p>First you will need to install the tachyon package:</p>

<pre><code>$ sudo yum install amplab-tachyon
</code></pre>

<p>Now you will need to update /etc/hadoop/core-site.xml configuration for hadoop to
enable map-reduce to take advantage of tachyon, by appending the following snippet:</p>

<pre><code>&lt;property&gt;
  &lt;name&gt;fs.tachyon.impl&lt;/name&gt;
  &lt;value&gt;tachyon.hadoop.TFS&lt;/value&gt;
&lt;/property&gt;
</code></pre>

<p>Now that all the plumbing is in place you can restart hadoop</p>

<pre><code>systemctl restart hadoop-namenode hadoop-datanode hadoop-nodemanager hadoop-resourcemanager
</code></pre>

<p>Next, make certain your local HDFS instance is up and running, then
you will need to perform a tachyon format.</p>

<pre><code>$ sudo runuser hdfs -s /bin/bash /bin/bash -c "tachyon.sh format"
&gt; Formatting Tachyon @ localhost
&gt; Deleting /var/lib/tachyon/journal/
&gt; Formatting hdfs://localhost:8020/tachyon/data
&gt; Formatting hdfs://localhost:8020/tachyon/workers
</code></pre>

<hr />

<h3>Initialization</h3>

<p>Prior to running the daemons you will need to mount the in-memory filesystem.</p>

<pre><code>$ sudo tachyon-mount.sh SudoMount
</code></pre>

<p>Now you can start the daemons.</p>

<pre><code>$ sudo systemctl start tachyon-master tachyon-slave
</code></pre>

<p>For completeness you can inspect the logs which are located in the standard system location</p>

<pre><code>$ ls -la /var/log/tachyon
</code></pre>

<hr />

<h3>Operation</h3>

<p>Once you&rsquo;ve verified tachyon is up and running, you can run a simple mapreduce application
as seen below:</p>

<pre><code>$ hadoop jar /usr/share/java/hadoop/hadoop-mapreduce-examples.jar wordcount
  tachyon://localhost:19998/user/tstclair/input/constitution.txt
  tachyon://localhost:19998/test1
</code></pre>

<p>You&rsquo;ll notice tha tachyon prefix attached to the input and output locations.  This enables
hadoop to start the TFS shim which will load and write to tachyon.  To verify you can run the following:</p>

<pre><code>$ sudo runuser hdfs -s /bin/bash /bin/bash -c "tachyon.sh tfs ls /test1"
&gt; 16.65 KB  02-17-2014 15:41:11:849  In Memory      /test1/part-r-00000
&gt; 0.00 B    02-17-2014 15:41:12:366  In Memory      /test1/_SUCCESS
</code></pre>

<p>If you&rsquo;re interested in grok'ing further you can probably find the part file under /mnt/ramdisk.</p>

<h2>Summary</h2>

<p>Tachyon provides reliable in memory file sharing across cluster frameworks, as we have seen
in our simple example. It also enables some very interesting prospects for other back end filesystems.</p>

<p>In future posts we&rsquo;ll explore more elaborate configurations using tachyon atop different frameworks and filesystems.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bootstrapping Your MapReduce 2.X Programming on Fedora 20]]></title>
    <link href="http://timothysc.github.io/timothysc.guthub.io/blog/2013/09/14/hadoop-mapreduce/"/>
    <updated>2013-09-14T10:00:00-05:00</updated>
    <id>http://timothysc.github.io/timothysc.guthub.io/blog/2013/09/14/hadoop-mapreduce</id>
    <content type="html"><![CDATA[<p><img src="http://timothysc.github.io/timothysc.guthub.io/images/ElephantCowboy.jpg" alt="Picture Courtesy of Mauro Flores jr"/></p>

<h2>Background</h2>

<p>Recently the BIG DATA SIG has added Hadoop 2.0.5 (or 2.X series) to the Fedora channels.  This
marks the first addition into <em>any</em> OS-distribution which meets all the standards, and system integration
requirements set forth by their steering committee(s).  Don&rsquo;t be fooled, bundling .jars into a package that
looks like a .rpm or .deb != a compliant package (not even by a long shot).</p>

<p>So to give some props to all the effort that it took to lasso this elephant, this post will outline how to bootstrap
the default installation for MapReduce development.</p>

<hr />

<h2>References</h2>

<ul>
<li><a href="https://fedoraproject.org/wiki/Changes/Hadoop">Fedora 20 Hadoop Integration</a></li>
<li><a href="https://fedoraproject.org/wiki/Big_data_SIG">Fedora BIG DATA SIG</a></li>
<li><a href="http://fedoraproject.org/wiki/FedUp">Upgrading with FedUp</a></li>
<li><a href="https://fedoraproject.org/wiki/Packaging:Guidelines?rd=Packaging/Guidelines">Fedora Packaging Guidelines</a></li>
</ul>


<hr />

<h2>Prerequisites</h2>

<ul>
<li>Fedora 20 Machine</li>
</ul>


<hr />

<h2>Installation and Setup (as root)</h2>

<p>First you will need to install all the default hadoop packages and tools required.</p>

<pre><code>yum install hadoop-common hadoop-hdfs hadoop-libhdfs hadoop-mapreduce hadoop-mapreduce-examples hadoop-yarn maven-* xmvn* 
</code></pre>

<p>Next you will need need to format your namenode:</p>

<pre><code>runuser hdfs -s /bin/bash /bin/bash -c "hadoop namenode -format"
</code></pre>

<p>Once your namenode has been formatted you can now start the daemons using the default service methods:</p>

<pre><code>systemctl start hadoop-namenode hadoop-datanode hadoop-nodemanager hadoop-resourcemanager
</code></pre>

<p>Finally you will want to create the default directories:</p>

<pre><code>hdfs-create-dirs
</code></pre>

<hr />

<h2>Setting up a Users Sandbox (as root)</h2>

<pre><code>runuser hdfs -s /bin/bash /bin/bash -c "hadoop fs -mkdir /user/tstclair"
runuser hdfs -s /bin/bash /bin/bash -c "hadoop fs -chown tstclair /user/tstclair"
</code></pre>

<hr />

<h2>Running WordCount (as user)</h2>

<p>For simplicity I&rsquo;ve setup a WordCount example on github that you can copy.</p>

<pre><code>git clone https://github.com/timothysc/hadoop-tests.github
</code></pre>

<p>Once it has downloaded you can put the example .txt file into your user location</p>

<pre><code>cd hadoop-tests/WordCount
hadoop fs -put constitution.txt /user/tstclair
</code></pre>

<p>Now you can build WordCount against the system installed .jars.</p>

<pre><code>mvn-rpmbuild package 
</code></pre>

<p>Finally you can run:</p>

<pre><code>hadoop jar wordcount.jar org.myorg.WordCount /user/tstclair /user/tstclair/output 
</code></pre>

<p>Feel free to cat the part-0000 file to see the results.</p>

<hr />

<h2>In Summary</h2>

<p>Hadoop 2.0.5 now acts like a standard package, with all the accoutrements folks have come to expect.</p>

<p><em>Giddyup!</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leveraging Systemd Cgroup Integration to Provide SLAs on Fedora 18 & 19]]></title>
    <link href="http://timothysc.github.io/timothysc.guthub.io/blog/2013/06/14/systemd-cgroup-sla/"/>
    <updated>2013-06-14T10:00:00-05:00</updated>
    <id>http://timothysc.github.io/timothysc.guthub.io/blog/2013/06/14/systemd-cgroup-sla</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>In the not-so-distant past, enterprise data centers would create silos for specific
services to gaurentee some metric of performance, or &ldquo;Service Level Agreement&rdquo; (SLA).  However,
this approach can be costly to create and maintain.</p>

<p>Enter the modern era of cloud computing, and one might wonder, &ldquo;Why not just put it in VM?&rdquo;.  For
some use cases this might work just fine, because the metrics are &ldquo;good-enough&rdquo;.   Despite this flexibility,
there are many cases where this approach simply won&rsquo;t meet some measure of performance.  I won&rsquo;t elaborate
on the details, but it doesn&rsquo;t take Schrödinger math to figure this out, because sometimes the cat
is dead even before you peak into the box. ;-)</p>

<p>Thus, in this post we will explore leveraging systemd cgroup integration to provide SLAs on Fedora.</p>

<hr />

<h2>References</h2>

<ul>
<li><a href="http://searchitchannel.techtarget.com/definition/service-level-agreement">Definition SLA</a></li>
<li><a href="https://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/">Redhat Cgroup Documentation</a></li>
<li><a href="http://0pointer.de/blog/projects/resources.html">Resource Management with Systemd</a></li>
<li><a href="http://0pointer.de/public/systemd-man/systemd.directives.html">Systemd Service Directives</a></li>
</ul>


<hr />

<h2>Prerequisites</h2>

<ul>
<li>Fedora 18 or 19 box(es).</li>
<li>Make certain you&rsquo;ve read the references, as I may gloss over some details in this post.</li>
</ul>


<hr />

<h2>Getting Started</h2>

<p>First you will need to choose a service which has been integrated with systemd that you can plan on tuning.
In this example I will use &lsquo;condor&rsquo;, but you could use any service that you desire.</p>

<pre><code> sudo yum install condor
</code></pre>

<p><strong>NOTE:</strong> You could do this with raw cgroups, but it becomes difficult to gaurentee performance unless
every service is in a group.  So systemd does a lot of the heavy lifting for us.</p>

<p>Next you will need to determine the metrics of performance that you want to provide for that service.  For the
purposes of simplicity, lets say we want to carve off 50% of the CPU for condor.  You can
also play with disk-io-bandwidth and network settings too, but I think I will leave that for another post
as this can be complicated enough.</p>

<p>In order to divide up your machine you will first need to determine the existing
shares on your machine.  This can be done by dumping the current cgroup settings to a file which
can then be analyzed to determine the new settings.</p>

<pre><code>cgsnapshot -s &gt; cgroup_snap.conf 
</code></pre>

<p>If you have a fairly basic setup you will notice the following pattern</p>

<pre><code># Configuration file generated by cgsnapshot
mount {
    cpuset = /sys/fs/cgroup/cpuset;
    cpu = /sys/fs/cgroup/cpu,cpuacct;
    cpuacct = /sys/fs/cgroup/cpu,cpuacct;
    memory = /sys/fs/cgroup/memory;
    devices = /sys/fs/cgroup/devices;
    freezer = /sys/fs/cgroup/freezer;
    net_cls = /sys/fs/cgroup/net_cls;
    blkio = /sys/fs/cgroup/blkio;
    perf_event = /sys/fs/cgroup/perf_event;
}

group system {
    cpu {
            cpu.rt_period_us="1000000";
            cpu.rt_runtime_us="0";
            cpu.cfs_period_us="100000";
            cpu.cfs_quota_us="-1";
            cpu.shares="1024";
    }
    cpuacct {
            cpuacct.usage="147354515620554";
    }
}

group system/condor.service {
    cpu {
            cpu.rt_period_us="1000000";
            cpu.rt_runtime_us="0";
            cpu.cfs_period_us="100000";
            cpu.cfs_quota_us="-1";
            cpu.shares="1024";
    }
    cpuacct {
            cpuacct.usage="146844720798260";
    }
}

... * services look ~= 
</code></pre>

<hr />

<h2>Analyzing your Configuration</h2>

<p>One thing you will notice is that systemd creates an implied hierarchy on your
machine by default, where each service has an equal amount of cpu.shares.  This means
when all services are contending for resources, each &ldquo;service&rdquo; gets an equal
share.</p>

<p>Lets elaborate on shares a bit.  Say you had two service S(a) = 1, and S(b) = 3 and each service
has multiple processes all contending for CPU.</p>

<pre><code>%CPU = service.cpu.share /(sum (service shares @ level)) 
%CPU[S(a)] = 1/4 = 25% 
%CPU[S(b)] = 3/4 = 75% 
</code></pre>

<p>So now lets extend this idea and create a simple hierarchy
where there are two groups, with each group having two services:</p>

<pre><code>            Share   Overall%
Group 1     1       25%
    S(a)        1       12.5%
    S(b)        1       12.5%
Group 2     3       75%
    S(c)        3       56.25%
    S(d)        1       18.75%
</code></pre>

<p>Hopefully this should be intuitive, however it can quickly goto plaid. Therefore, it&rsquo;s
important to have a handle on how many services you have planed for a given machine, and
your intended hierarchy.  Thus the cost of reliable performance is extra complexity, which
isn&rsquo;t so bad provided you&rsquo;ve done your math.</p>

<hr />

<h2>Altering your Configuration##</h2>

<p>So now lets provision condor such that it has 50% of the CPU.  First we need to get a count
of number of services that exist on the machine.</p>

<pre><code>$ cgsnapshot -s | grep [.]service | wc -l
30
</code></pre>

<p>As you can see from the previous example, and from the documentation, the default cpu.shares
given to a service is 1024.  Thus if we want 50% CPU:</p>

<pre><code>.50 = condor.cpu.shares/(1024*29 + condor.cpu.shares)
512*(29) + .50*condor.cpu.shares = condor.cpu.shares
14848 = (1-.50)*condor.cpu.shares 
condor.cpu.shares = 14848/.50 = 29696
</code></pre>

<p>Seem nutty? GOOD! Don&rsquo;t do it this way!  Instead lets use the idea of promoting a top level
group:</p>

<pre><code>vim /usr/lib/systemd/system/condor.service

[Service]
ControlGroup=cpu:/condor
CPUShares=1024
</code></pre>

<p>Once we exit we will need to restart the daemon and verify it worked.</p>

<pre><code>systemctl daemon-reload
systemctl restart condor.service
</code></pre>

<p>You may need to remove any legacy cruft from cgroups, or reboot, but you can compare the two configuration files.</p>

<pre><code>cgsnapshot -s &gt; cgroup_snap_2.conf
</code></pre>

<p>Next you will want to submit a whole bunch of condor jobs, and try to load down the other services.
To verify that your machine is behaving as expected you can run:</p>

<pre><code>systemd-cgtop
</code></pre>

<p>In this example it can be difficult when you have 30 services to accurately test that you are
guaranteed 50% so I would recommend that the reader promote a couple of services to the top level
and have them compete in a controlled experiment.</p>

<hr />

<h2>In Summary</h2>

<p>Systemd&rsquo;s integration with cgroups is a many splendid thing, and when used correctly can
give administrators and developers another tool in which to help create SLAs in their datacenter.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Configuring a Personal Hadoop Development Environment on Fedora 18]]></title>
    <link href="http://timothysc.github.io/timothysc.guthub.io/blog/2013/04/22/personalhadoop/"/>
    <updated>2013-04-22T10:00:00-05:00</updated>
    <id>http://timothysc.github.io/timothysc.guthub.io/blog/2013/04/22/personalhadoop</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>The following post outlines a setup and configuration of a &ldquo;personal hadoop&rdquo; development environment that is much akin to a &ldquo;personal condor&rdquo; setup.
The primary purpose is to have a single source for configuration and logs along with a soft-link to development built binaries such that switching
to a different build is a matter of updating a soft-link while maintaining all other data and configuration.</p>

<hr />

<h2>Use Cases</h2>

<ul>
<li>Comparison testing in a local sandbox without altering an existing system installation.</li>
<li>Single source configuration and logs</li>
<li>&hellip;</li>
</ul>


<hr />

<h2>References</h2>

<p>Inter-webz:</p>

<ul>
<li><a href="http://wiki.apache.org/hadoop/HowToSetupYourDevelopmentEnvironment">http://wiki.apache.org/hadoop/HowToSetupYourDevelopmentEnvironment</a></li>
<li><a href="http://vichargrave.com/create-a-hadoop-build-and-development-environment-for-hadoop/">http://vichargrave.com/create-a-hadoop-build-and-development-environment-for-hadoop/</a></li>
<li><a href="http://www.michael-noll.com/tutorials/running-hadoop-on-ubuntu-linux-single-node-cluster/">http://www.michael-noll.com/tutorials/running-hadoop-on-ubuntu-linux-single-node-cluster/</a></li>
<li><a href="http://wiki.apache.org/hadoop/">http://wiki.apache.org/hadoop/</a></li>
<li><a href="http://docs.hortonworks.com/CURRENT/index.htm#Appendix/Configuring_Ports/HDFS_Ports.htm">http://docs.hortonworks.com/CURRENT/index.htm#Appendix/Configuring_Ports/HDFS_Ports.htm</a></li>
</ul>


<p>Books:</p>

<ul>
<li><a href="http://www.amazon.com/Hadoop-The-Definitive-Guide-ebook/dp/B0082FE448/ref=dp_kinw_strp_1">Hadoop &ldquo;The Definitive Guide&rdquo;</a></li>
</ul>


<hr />

<h2>Disclaimers</h2>

<ul>
<li>Currently this is a non-native development setup that uses the existing maven dependencies.  For details on native packaging please visit <a href="https://fedoraproject.org/wiki/Features/Hadoop">https://fedoraproject.org/wiki/Features/Hadoop</a></li>
<li>The setup listed below is for creating &ldquo;Single-Node-Cluster&rdquo;</li>
</ul>


<hr />

<h2>Prerequisites</h2>

<h3>Configure Password-less ssh</h3>

<pre><code>yum install openssh openssh-clients openssh-server
# generate a public/private key, if you don't already have one
ssh-keygen -t dsa -P '' -f ~/.ssh/id_dsa
cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys
chmod 600 ~/.ssh/*

# testing ssh:
ps -ef | grep sshd     # verify sshd is running
ssh localhost          # accept the certification when prompted
sudo passwd root       # Make sure the root has a password
</code></pre>

<h3>Install Other Build Dependencies</h3>

<pre><code>yum install cmake git subversion dh-make ant autoconf automake sharutils libtool asciidoc xmlto curl protobuf-compiler gcc-c++ 
</code></pre>

<h3>Install Java And Deps</h3>

<pre><code>yum install java-1.7.0-openjdk java-1.7.0-openjdk-devel java-1.7.0-openjdk-javadoc *maven*
</code></pre>

<p>append to your .bashrc file:
    export JVM_ARGS=&ldquo;-Xmx1024m -XX:MaxPermSize=512m&rdquo;
    export MAVEN_OPTS=&ldquo;-Xmx1024m -XX:MaxPermSize=512m&rdquo;</p>

<p><strong>NOTE:</strong> These instructions have been updated to build against OpenJDK 7 on F18.  Currently (4/25/13), builds are clean but there are
some test failures.  To get a complete list of failed tests run:</p>

<pre><code> mvn install -Dmaven.test.failure.ignore=true
</code></pre>

<hr />

<h2>Building and Setting up a &ldquo;personal-hadoop&rdquo;</h2>

<h3>Building</h3>

<pre><code>git clone git://git.apache.org/hadoop-common.git
cd hadoop-common
git checkout -b branch-2.0.4-alpha origin/branch-2.0.4-alpha
mvn clean package -Pdist -DskipTests
</code></pre>

<h3>Creating Your &ldquo;personal-hadoop&rdquo; Sandbox</h3>

<p>In this configuration we default to <strong>/home/tstclair</strong></p>

<pre><code>cd ~
mkdir personal-hadoop
cd personal-hadoop
mkdir -p conf data name logs/yarn
ln -sf &lt;your-git-loc&gt;/hadoop-dist/target/hadoop-2.0.4-alpha home
</code></pre>

<h3>Override your environment</h3>

<p>append to your .bashrc file:
    # Hadoop env override:
    export HADOOP_BASE_DIR=${HOME}/personal-hadoop
    export HADOOP_LOG_DIR=${HOME}/personal-hadoop/logs
    export HADOOP_PID_DIR=${HADOOP_BASE_DIR}
    export HADOOP_CONF_DIR=${HOME}/personal-hadoop/conf
    export HADOOP_COMMON_HOME=${HOME}/personal-hadoop/home
    export HADOOP_HDFS_HOME=${HADOOP_COMMON_HOME}
    export HADOOP_MAPRED_HOME=${HADOOP_COMMON_HOME}
    # Yarn env override:
    export HADOOP_YARN_HOME=${HADOOP_COMMON_HOME}
    export YARN_LOG_DIR=${HADOOP_LOG_DIR}/yarn
    #classpath override to search hadoop loc
    export CLASSPATH=/usr/share/java/:${HADOOP_COMMON_HOME}/share
    #Finally update your PATH
    export PATH=${HADOOP_COMMON_HOME}/bin:${HADOOP_COMMON_HOME}/sbin:${HADOOP_COMMON_HOME}/libexec:${PATH}</p>

<h3>Verify your setup</h3>

<pre><code>source ~/.bashrc
which hadoop    # verify it should be ${HOME}/personal-hadoop/home/bin  
hadoop -help    # verify classpath is correct.
</code></pre>

<h3>Creating Initial Single Configuration Node Setup</h3>

<p>First copy in the default configuration files:
    cp ${HADOOP_COMMON_HOME}/etc/hadoop/* ${HADOOP_BASE_DIR}/conf</p>

<p>NOTE: As your configuration testing space expands it is sometimes useful to have your conf directory to also be a softlink of configuration templates.</p>

<p>Next update your <em>hdfs-site.xml</em> with the following:
File /home/tstclair/work/spaces/timothysc.github.com/source/downloads/code/xml/hdfs-site.xml could not be found</p>

<p>Append, or update, your <em>mapred-site.xml</em> with the following:
File /home/tstclair/work/spaces/timothysc.github.com/source/downloads/code/xml/mapred-site.xml could not be found</p>

<p>Finally update your <em>yarn-site.xml</em> with the following:
File /home/tstclair/work/spaces/timothysc.github.com/source/downloads/code/xml/yarn-site.xml could not be found</p>

<p><strong>NOTE:</strong> You may notice that I&rsquo;ve included default variables and their corresponding port numbers to ease default hunting.</p>

<h2>Starting Your Single Node Hadoop Cluster</h2>

<p>Format your namenode (only needed for the 1st setup):
    hadoop namenode -format
    #verify output is correct.</p>

<p>Start HDFS:
    start-dfs.sh</p>

<p>open a browser to <a href="http://localhost:50070">http://localhost:50070</a> and verify you have 1 live node.</p>

<p>Next start yarn:
    start-yarn.sh</p>

<p>Verify the logs show it&rsquo;s running normally.</p>

<p>Finally check to see if you can run an MR application:
    cd ${HADOOP_COMMON_HOME}/share/hadoop/mapreduce
    hadoop jar hadoop-mapreduce-example-2.0.4-alpha.jar randomwriter out</p>

<p><strong>HAPPY HACKING!!!</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Per-Process Mount Namespaces]]></title>
    <link href="http://timothysc.github.io/timothysc.guthub.io/blog/2013/02/22/perprocess/"/>
    <updated>2013-02-22T10:00:00-06:00</updated>
    <id>http://timothysc.github.io/timothysc.guthub.io/blog/2013/02/22/perprocess</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>&ldquo;Isolation&rdquo; in modern computing comes in many flavors and functions.  Virtual machines, c-groups, chroots/jails,
sanboxing, and namespaces all have a role to play.  In this post we will review process mount namespace isolation, which allows a process to isolate
its mount points from the outside world.  Furthermore, it enables cleanup of that namespace, which is highly useful in grid applications.</p>

<hr />

<h2>References</h2>

<p>Before you dive too deep into the code below, it&rsquo;s important to read up on some kernel and system goodies:</p>

<ul>
<li> <a href="http://lwn.net/Articles/159077/">http://lwn.net/Articles/159077/</a></li>
<li> <a href="http://lwn.net/Articles/159092/">http://lwn.net/Articles/159092/</a></li>
<li> <a href="http://www.freedesktop.org/software/systemd/man/systemd.exec.html">http://www.freedesktop.org/software/systemd/man/systemd.exec.html</a></li>
<li> <a href="http://www.ibm.com/developerworks/linux/library/l-mount-namespaces/index.html">http://www.ibm.com/developerworks/linux/library/l-mount-namespaces/index.html</a></li>
</ul>


<hr />

<h2>Deep Thoughts</h2>

<p>It may take some time to digest all of the reading and figure out how to apply namespaces to your application.  I recommend
re-reading the use cases outlined kernel documentation on shared subtrees.  The nugget of goodness that we wish to apply here is under
section 4B.</p>

<pre><code>A process wants its mounts invisible to any other process, but
still be able to see the other system mounts.

Solution:

To begin with, the administrator can mark the entire mount tree
as shareable.

mount --make-rshared /

A new process can clone off a new namespace. And mark some part
of its namespace as slave

mount --make-rslave /myprivatetree

Hence forth any mounts within the /myprivatetree done by the
process will not show up in any other namespace. However mounts
done in the parent namespace under /myprivatetree still shows
up in the process's namespace.
</code></pre>

<p>In summary, you will want your parent process to recursively slave mount /your/loc, as not to pollute the inherited namespace especially
in cases where the mount points have shared propagation enabled (Default in Fedora).</p>

<hr />

<h2>Testing</h2>

<p>So I&rsquo;ve created a simple test application which shows how you to hide subprocess mount points.</p>

<div><script src='https://gist.github.com/5015879.js'></script>
<noscript><pre><code>#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include &lt;sched.h&gt;
#include &lt;sys/mount.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;dirent.h&gt;
#include &lt;stdarg.h&gt;

#define _LOG( ... ) {\
FILE * fp = fopen(&quot;namespace.txt&quot;, &quot;a+&quot;); \
fprintf(fp, __VA_ARGS__); \
fclose(fp); }

/////////////////////////////////////////////////////////
// output the contents of a directory for checking 
// contents to verify if it&#39;s mounted or not.
void output_dir(char * pszDir)
{
    DIR *dp;
    struct dirent *ep;     
    dp = opendir (pszDir);

    _LOG( &quot;[%d] Contents of %s\n&quot;, getpid(), pszDir);
    
    if (dp != NULL)
    {
        while (ep = readdir (dp))
            _LOG( &quot;%s\n&quot;, ep-&gt;d_name );
    
        closedir (dp);
    }
    else
        perror (&quot;Couldn&#39;t open the directory&quot;);
}

/////////////////////////////////////////////////////////
// main entry point
int main(int argc, char ** argv)
{

    int ret = 0;

        _LOG( &quot;[%d] STARTING \n&quot;, getpid());
    
    // fork fuse mount test application
    int pid = fork();
    if (!pid) {        
            // create a new process mount namespace
            // don&#39;t muck with the parents, it could leak!
            ret = unshare(CLONE_NEWNS);
            if (ret) {
                _LOG(&quot;FAILED TO UNSHARE\n&quot;);
                return errno;
            }
        
            _LOG( &quot;[%d] UNSHARE COMPLETE\n&quot;, getpid());
        
            // recursively mount everything below / as slave in new pid-namespace
            // this should override shared propagation 
            ret = mount(&quot;&quot;, &quot;/&quot;, &quot;dontcare&quot;, MS_REC|MS_SLAVE, &quot;&quot;);
            if (ret) {
               _LOG( &quot;failed to mark / rslave for\n&quot; );
               return errno;
            }
        
            _LOG( &quot;[%d] SLAVE MOUNT COMPLETE\n&quot;, getpid());
        
            // Now you can perform any mounts below to your hearts content
            // In our case we will kick a script that does a fuse mount
            char *argv[2];
            argv[0] = strdup(&quot;testfuse.sh&quot;);
            argv[1] = NULL;
            execv(&quot;testfuse.sh&quot;, argv);
        
       _exit(errno);
    } else if (pid == -1) {
        ret = errno;
    } else {
        int status;
        errno = EINVAL;
        ret = waitpid(pid, &amp;status, 0);
        ret = ret == pid ? 0 : -1;
        if (!ret) {
            ret = status;
        }

        output_dir(&quot;./fusemount_test/&quot;);

    }   

    _LOG (&quot;[%d] RET=%d\n&quot;,getpid(), ret);

    return ret;

}</code></pre></noscript></div>


<p>For more details, please checkout my <a href="http://github.com/timothysc/tests/tree/master/per_process_mounts">tests repo.</a></p>

<hr />

<h2>Applications</h2>

<ul>
<li>Cleaning condor job mounts ;-)</li>
<li>Application security</li>
<li>User security</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Override HTCondor Installation With Sudo]]></title>
    <link href="http://timothysc.github.io/timothysc.guthub.io/blog/2012/11/12/condor-sudo/"/>
    <updated>2012-11-12T03:00:00-06:00</updated>
    <id>http://timothysc.github.io/timothysc.guthub.io/blog/2012/11/12/condor-sudo</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>As a developer, I often find myself wanting to iterate on a build, and test in a sandboxed environment.  Isolating the environment ensures that your changes work well in a controlled experiment, but it has one fundamental flaw, it&rsquo;s not realistic.  In order to truly test a complicated system it&rsquo;s best to put it into some production environment.  This is great for testing, but it has been known to give admins a headache, because you are mucking with a known good installation.  So in this post we will set about the task of overriding an installtion of HTCondor using sudo while keeping the following requirements in mind:</p>

<h3>Requirements</h3>

<ul>
<li>Don&rsquo;t alter the existing system installation (binaries or config files).</li>
<li>Be able to reference any custom developer build.</li>
<li>Be able to easily change back to the known good installation with little/no effort.</li>
</ul>


<hr />

<h2>Getting Started</h2>

<p>Before you begin you will need a machine which already has HTCondor installed on it, and all the necessary development tools in order to create a custom build.  You will also need to obtain the <a href="https://github.com/htcondor/htcondor">source tree for HTCondor</a>, and follow the instructions on <a href="https://condor-wiki.cs.wisc.edu/index.cgi/wiki?p=BuildModernization">how to build condor.</a>  I typically &lsquo;alias cmake&rsquo; in my environment with all the clever developer magic to make a sandbox&rsquo;d installation out of the gate.</p>

<pre><code>alias cmake='cmake -DCMAKE_INSTALL_PREFIX:PATH=${PWD}/release_dir \
-DBUILDID:STRING=tstclair_local -DWANT_CONTRIB:BOOL=TRUE \
-DWANT_FULL_DEPLOYMENT:BOOL=FALSE -D_VERBOSE:BOOL=TRUE \
-DWANT_MAN_PAGES:BOOL=TRUE -D_DEBUG:BOOL=TRUE'

cmake . &amp;&amp; make install 
</code></pre>

<p>Lastly you will need an account which has sudo privs on the machine where you will be tinkering.</p>

<hr />

<h2>Setting up a Sandbox</h2>

<p>Once you&rsquo;ve created build for the target machine that you would like to test, you will need to create a sandbox location which is also accessible by the &lsquo;condor&rsquo; user, I typically use /tmp.</p>

<pre><code>mkdir /tmp/mycondor
cp -r release_dir /tmp/mycondor 
</code></pre>

<p>Next you will want to drop 3 files into your sandbox directory.</p>

<p>The first file is a simple bash script which kicks off your sandbox&rsquo;d condor ensuring that all the correct environment variables are passed through sudo so that HTCondor can properly execute out of your sandbox.<br/>
File /home/tstclair/work/spaces/timothysc.github.com/source/downloads/code/scripts/sudo_condor.sh could not be found
If you are testing your client tools, you will also want to mundge your PATH in your testing shell as seen in the script.</p>

<p>The next file is a script which acts as a piped config script.  In HTCondor, there is a feature which allows admins to generate/mundge the parameters which can be passed in on intialization and reconfig.  It turns out this is useful in meeting our previously mentioned requirement of not mucking with the existing configs while still being able to customize as seen below:
File /home/tstclair/work/spaces/timothysc.github.com/source/downloads/code/scripts/override.sh could not be found</p>

<p>The final file is an optional condor_config.local file, which you can create.  This file is appended to the end of the existing config and allows the developers, or admins, to lay out any configuration that they desire or even override the system to behave the way they would like.</p>

<p>Finally you will need to adjust the access permission so that the &lsquo;condor&rsquo; user can access the shared location.</p>

<pre><code>sudo chown -R "root:root" /tmp/mycondor
</code></pre>

<p>Now lets rock N' roll!</p>

<pre><code>cd /tmp/mycondor
./sudo_condor.sh
</code></pre>

<p>You&rsquo;ve now taken over a existing machine in your pool using all the configuration settings that were there, while still allowing your own config magic.  You should take heed though, if you are testing any changes to condors internal files, you could possibly corrupt what is there.  To avoid this, you can override the SPOOL and EXECUTE directories in your condor_config.local file.</p>

<hr />

<h2>Verify its correct</h2>

<p>The easiest way to verify correctness is to check that the preamble in the logs(/var/log/condor) contains your BUILDID string, in this case it was &lsquo;tstclair_local&rsquo;.</p>

<hr />

<h2>Potential Use Cases</h2>

<p>It&rsquo;s fairly obvious why a developer would want to do this, but it has many potential use cases outside of just development, which include:</p>

<ul>
<li>Beta testing a new installation prior to a pool upgrade.</li>
<li>Testing version compatibility across releases.</li>
<li>Playing with new shiney condor features in a existing pool.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elastic Grid With Condor and oVirt Integration]]></title>
    <link href="http://timothysc.github.io/timothysc.guthub.io/blog/2012/09/21/condor-n-overt/"/>
    <updated>2012-09-21T03:50:00-05:00</updated>
    <id>http://timothysc.github.io/timothysc.guthub.io/blog/2012/09/21/condor-n-overt</id>
    <content type="html"><![CDATA[<h2>Background</h2>

<p>Gone are the days where an IT administrator could procure a dedicated compute cluster for a single task, so it is often the case where admins are asked to do more with existing resources where possible, especially those which are underutilized.  There are several existing solutions to oversubscription, but few that remain &ldquo;general purpose&rdquo; while adapting to the environment as the load within the cluster changes.  Enter Condor, which has been most well known for its batch processing capabilities, but can also be leveraged in many ways as an IaaS tool when coupled with oVirt.</p>

<p>There have been numerous refs in the past to using the <a href="http://youtu.be/kPi8ickYN84">two tools together</a>, but in this post we will explore the idea of using Condor&rsquo;s integration with oVirt to spin the resources directly from Condor, and briefly cover how administrators could use this capability to spin resources &ldquo;on demand&rdquo;.</p>

<hr />

<h2>Setup</h2>

<p>Before you begin, you will need to configure <a href="http://www.ovirt.org/">oVirt</a> and a <a href="http://deltacloud.apache.org/">deltacloud server</a> such that your preconfigured images can be spun via the deltacloud api remotely.  To verify, you can run a simple test program to ensure that it works from a remote machine, as if it were run from condor.</p>

<p>File /home/tstclair/work/spaces/timothysc.github.com/source/downloads/code/c/deltacloud_test.c could not be found</p>

<p>Once this is done, you will then need to install condor-deltacloud-gahp on the submit machines where you want to spin the resources.</p>

<hr />

<h2>Spinning a oVirt Instance with Condor</h2>

<p>Provided you&rsquo;ve setup all the pieces above, you should be able to just submit a grid universe job which referenced the images that you wish to start up.</p>

<pre><code>universe = grid
grid_resource = deltacloud http://ovirt.yourdomain.com:3002/api
executable = ovirt_spin_test
deltacloud_username = vdcadmin@ovirt.yourdomain.com
deltacloud_password_file = user_pwd

# Just specify the rhevm instance name
deltacloud_instance_name = kvm_test_image_64

log = job_deltacloud_basic_$(cluster)_$(process).log
notification = NEVER
queue
</code></pre>

<hr />

<h2>Potential Use Cases</h2>

<p>Given the tight level of integration from Condor and oVirt via deltacloud there are a liteny of use cases which could be crafted by administrators to enable the auto spinning of images from condor, which include:</p>

<ul>
<li>Using the JobRouter to configure for overflow</li>
<li>Using condor-cron to spin images based on time based activites</li>
<li>Using DAGMan workflows along with a monitoring activity to spin and clean resources, based on availability</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dust Off Nuke It From Orbit]]></title>
    <link href="http://timothysc.github.io/timothysc.guthub.io/blog/2012/09/12/dust-off-nuke-it-from-orbit/"/>
    <updated>2012-09-12T04:12:00-05:00</updated>
    <id>http://timothysc.github.io/timothysc.guthub.io/blog/2012/09/12/dust-off-nuke-it-from-orbit</id>
    <content type="html"><![CDATA[<p>So in an effort to single source the numerous blogs, and other random bitz which have been smatter across the internet, I’ve decided to start putting all my professional efforts into one loc where other developers can easily find sources, blogs, etc.</p>
]]></content>
  </entry>
  
</feed>
